#!/bin/bash

# Script unificado de backup y restauración para Cursor
# Uso:
#   cursor-backup [directorio_destino]              - Backup completo
#   cursor-backup -p [directorio_destino]           - Backup público (sin info sensible)
#   cursor-backup -r [archivo_backup.tar.gz]         - Restaurar backup

set -e  # Salir si hay algún error

# Colores para output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Directorios de origen/destino
CURSOR_USER_DIR="$HOME/Library/Application Support/Cursor/User"
CURSOR_EXTENSIONS_DIR="$HOME/.cursor/extensions"

# Variables para flags
RESTORE_MODE=false
PUBLIC_MODE=false
BACKUP_FILE=""
BACKUP_BASE_DIR=""
OUTPUT_DIR=""
INPUT_FILE=""

# Función para mostrar ayuda
show_help() {
    echo -e "${BLUE}Cursor Backup Tool${NC}"
    echo ""
    echo "Uso:"
    echo "  cursor-backup [directorio_destino]                    # Backup completo"
    echo "  cursor-backup -p, --public [directorio_destino]        # Backup público (sin info sensible)"
    echo "  cursor-backup -w, --without-sensitive-info [directorio] # Backup público (sin info sensible)"
    echo "  cursor-backup -r, --restore [archivo_backup.tar.gz]    # Restaurar backup"
    echo ""
    echo "Opciones:"
    echo "  -h, --help                    Mostrar esta ayuda"
    echo "  -r, --restore                 Modo restauración"
    echo "  -p, --public                  Backup público (sin información sensible)"
    echo "  -w, --without-sensitive-info  Backup público (sin información sensible)"
    echo "  -o, --output DIR              Especificar directorio de destino para el backup"
    echo "  -f, --file ARCHIVO            Especificar archivo de backup para restaurar"
    echo ""
    echo "Ejemplos:"
    echo "  cursor-backup                                    # Backup completo en directorio actual"
    echo "  cursor-backup ~/backups                          # Backup completo en ~/backups"
    echo "  cursor-backup -o ~/backups                      # Backup completo usando flag -o"
    echo "  cursor-backup -p                                 # Backup público en directorio actual"
    echo "  cursor-backup -p -o ~/backups                   # Backup público en ~/backups"
    echo "  cursor-backup -r backup.tar.gz                 # Restaurar backup"
    echo "  cursor-backup -r -f backup.tar.gz               # Restaurar backup usando flag -f"
}

# Parsear argumentos
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -r|--restore)
            RESTORE_MODE=true
            shift
            ;;
        -p|--public|-w|--without-sensitive-info)
            PUBLIC_MODE=true
            shift
            ;;
        -o|--output)
            if [ -z "$2" ]; then
                echo -e "${RED}Error: -o/--output requiere un directorio${NC}"
                exit 1
            fi
            OUTPUT_DIR="$2"
            shift 2
            ;;
        -f|--file)
            if [ -z "$2" ]; then
                echo -e "${RED}Error: -f/--file requiere un archivo${NC}"
                exit 1
            fi
            INPUT_FILE="$2"
            shift 2
            ;;
        -*)
            echo -e "${RED}Error: Opción desconocida: $1${NC}"
            show_help
            exit 1
            ;;
        *)
            # Si hay flags -o o -f, ignorar argumentos posicionales
            if [ "$RESTORE_MODE" = true ]; then
                if [ -z "$INPUT_FILE" ]; then
                    BACKUP_FILE="$1"
                else
                    echo -e "${YELLOW}Advertencia: Ignorando argumento posicional '$1' (ya se especificó con -f/--file)${NC}"
                fi
            else
                if [ -z "$OUTPUT_DIR" ]; then
                    BACKUP_BASE_DIR="$1"
                else
                    echo -e "${YELLOW}Advertencia: Ignorando argumento posicional '$1' (ya se especificó con -o/--output)${NC}"
                fi
            fi
            shift
            ;;
    esac
done

# Usar flags si están definidos, sino usar argumentos posicionales
if [ "$RESTORE_MODE" = true ]; then
    if [ -n "$INPUT_FILE" ]; then
        BACKUP_FILE="$INPUT_FILE"
    fi
else
    if [ -n "$OUTPUT_DIR" ]; then
        BACKUP_BASE_DIR="$OUTPUT_DIR"
    fi
fi

# ============================================================================
# FUNCIÓN: BACKUP COMPLETO
# ============================================================================
do_backup_complete() {
    local dest_dir="${1:-$(pwd)}"
    
    # Validar que el directorio de destino existe o puede ser creado
    if [ ! -d "$dest_dir" ]; then
        echo -e "${BLUE}Creando directorio de destino: $dest_dir${NC}"
        mkdir -p "$dest_dir" || {
            echo -e "${YELLOW}Error: No se pudo crear el directorio de destino: $dest_dir${NC}"
            exit 1
        }
    fi
    
    TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    BACKUP_DIR="$dest_dir/cursor_backup_$TIMESTAMP"
    
    echo -e "${BLUE}========================================${NC}"
    echo -e "${BLUE}  Backup de Cursor${NC}"
    echo -e "${BLUE}========================================${NC}"
    echo ""
    
    # Verificar que los directorios existen
    if [ ! -d "$CURSOR_USER_DIR" ]; then
        echo -e "${YELLOW}Advertencia: No se encontró el directorio de configuraciones: $CURSOR_USER_DIR${NC}"
        exit 1
    fi
    
    if [ ! -d "$CURSOR_EXTENSIONS_DIR" ]; then
        echo -e "${YELLOW}Advertencia: No se encontró el directorio de extensiones: $CURSOR_EXTENSIONS_DIR${NC}"
        exit 1
    fi
    
    # Crear directorio de backup
    mkdir -p "$BACKUP_DIR"
    echo -e "${GREEN}✓${NC} Directorio de backup creado: $BACKUP_DIR"
    echo ""
    
    # Backup de configuraciones
    echo -e "${BLUE}Copiando configuraciones...${NC}"
    if [ -d "$CURSOR_USER_DIR" ]; then
        cp -R "$CURSOR_USER_DIR" "$BACKUP_DIR/User"
        echo -e "${GREEN}✓${NC} Configuraciones copiadas"
        
        # Mostrar tamaño
        SIZE=$(du -sh "$BACKUP_DIR/User" | cut -f1)
        echo -e "  Tamaño: $SIZE"
    else
        echo -e "${YELLOW}⚠${NC} Directorio de configuraciones no encontrado"
    fi
    echo ""
    
    # Backup de extensiones
    echo -e "${BLUE}Copiando extensiones...${NC}"
    if [ -d "$CURSOR_EXTENSIONS_DIR" ]; then
        cp -R "$CURSOR_EXTENSIONS_DIR" "$BACKUP_DIR/extensions"
        echo -e "${GREEN}✓${NC} Extensiones copiadas"
        
        # Contar extensiones
        EXT_COUNT=$(find "$BACKUP_DIR/extensions" -maxdepth 1 -type d | wc -l | tr -d ' ')
        echo -e "  Extensiones encontradas: $((EXT_COUNT - 1))"
        
        # Mostrar tamaño
        SIZE=$(du -sh "$BACKUP_DIR/extensions" | cut -f1)
        echo -e "  Tamaño: $SIZE"
    else
        echo -e "${YELLOW}⚠${NC} Directorio de extensiones no encontrado"
    fi
    echo ""
    
    # Crear archivo de información
    INFO_FILE="$BACKUP_DIR/backup_info.txt"
    cat > "$INFO_FILE" << EOF
Backup de Cursor
================
Fecha: $(date)
Sistema: $(uname -a)

Directorios respaldados:
- Configuraciones: $CURSOR_USER_DIR
- Extensiones: $CURSOR_EXTENSIONS_DIR

Para restaurar:
1. Cierra Cursor completamente
2. Restaura los archivos desde este backup
3. Reinicia Cursor
EOF
    
    echo -e "${GREEN}✓${NC} Archivo de información creado"
    echo ""
    
    # Crear comprimido tar.gz
    echo -e "${BLUE}Comprimiendo backup...${NC}"
    ARCHIVE_NAME="cursor_backup_$TIMESTAMP.tar.gz"
    cd "$dest_dir"
    tar -czf "$ARCHIVE_NAME" "cursor_backup_$TIMESTAMP"
    echo -e "${GREEN}✓${NC} Backup comprimido: $ARCHIVE_NAME"
    
    # Verificar que el archivo se creó correctamente antes de eliminar la carpeta
    if [ -f "$dest_dir/$ARCHIVE_NAME" ]; then
        # Mostrar tamaño del archivo comprimido
        ARCHIVE_SIZE=$(du -sh "$ARCHIVE_NAME" | cut -f1)
        echo -e "  Tamaño del archivo: $ARCHIVE_SIZE"
        echo ""
        
        # Eliminar la carpeta temporal
        echo -e "${BLUE}Eliminando carpeta temporal...${NC}"
        rm -rf "$BACKUP_DIR"
        echo -e "${GREEN}✓${NC} Carpeta temporal eliminada"
        echo ""
    else
        echo -e "${YELLOW}⚠${NC} Error al crear el archivo comprimido, se mantiene la carpeta temporal"
        echo ""
    fi
    
    # Resumen final
    echo -e "${BLUE}========================================${NC}"
    echo -e "${GREEN}✓ Backup completado exitosamente${NC}"
    echo -e "${BLUE}========================================${NC}"
    echo ""
    echo -e "Ubicación del backup:"
    echo -e "  Archivo comprimido: ${GREEN}$dest_dir/$ARCHIVE_NAME${NC}"
    echo ""
}

# ============================================================================
# FUNCIÓN: BACKUP PÚBLICO (SIN INFO SENSIBLE)
# ============================================================================
do_backup_public() {
    local dest_dir="${1:-$(pwd)}"
    
    # Validar que el directorio de destino existe o puede ser creado
    if [ ! -d "$dest_dir" ]; then
        echo -e "${BLUE}Creando directorio de destino: $dest_dir${NC}"
        mkdir -p "$dest_dir" || {
            echo -e "${YELLOW}Error: No se pudo crear el directorio de destino: $dest_dir${NC}"
            exit 1
        }
    fi
    
    TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    BACKUP_DIR="$dest_dir/cursor_backup_public_$TIMESTAMP"
    
    echo -e "${BLUE}========================================${NC}"
    echo -e "${BLUE}  Backup Público de Cursor${NC}"
    echo -e "${BLUE}  (Sin información sensible)${NC}"
    echo -e "${BLUE}========================================${NC}"
    echo ""
    
    # Verificar que los directorios existen
    if [ ! -d "$CURSOR_USER_DIR" ]; then
        echo -e "${YELLOW}Advertencia: No se encontró el directorio de configuraciones: $CURSOR_USER_DIR${NC}"
        exit 1
    fi
    
    if [ ! -d "$CURSOR_EXTENSIONS_DIR" ]; then
        echo -e "${YELLOW}Advertencia: No se encontró el directorio de extensiones: $CURSOR_EXTENSIONS_DIR${NC}"
        exit 1
    fi
    
    # Crear directorio de backup
    mkdir -p "$BACKUP_DIR"
    echo -e "${GREEN}✓${NC} Directorio de backup creado: $BACKUP_DIR"
    echo ""
    
    # Backup de configuraciones (solo archivos seguros)
    echo -e "${BLUE}Copiando configuraciones (sin datos sensibles)...${NC}"
    if [ -d "$CURSOR_USER_DIR" ]; then
        mkdir -p "$BACKUP_DIR/User"
        
        # Copiar settings.json si existe
        if [ -f "$CURSOR_USER_DIR/settings.json" ]; then
            cp "$CURSOR_USER_DIR/settings.json" "$BACKUP_DIR/User/settings.json"
            echo -e "${GREEN}✓${NC} settings.json copiado"
        fi
        
        # Copiar keybindings.json si existe
        if [ -f "$CURSOR_USER_DIR/keybindings.json" ]; then
            cp "$CURSOR_USER_DIR/keybindings.json" "$BACKUP_DIR/User/keybindings.json"
            echo -e "${GREEN}✓${NC} keybindings.json copiado"
        fi
        
        # Copiar snippets si existe
        if [ -d "$CURSOR_USER_DIR/snippets" ]; then
            cp -R "$CURSOR_USER_DIR/snippets" "$BACKUP_DIR/User/snippets"
            echo -e "${GREEN}✓${NC} snippets copiados"
        fi
        
        # Copiar tasks.json si existe
        if [ -f "$CURSOR_USER_DIR/tasks.json" ]; then
            cp "$CURSOR_USER_DIR/tasks.json" "$BACKUP_DIR/User/tasks.json"
            echo -e "${GREEN}✓${NC} tasks.json copiado"
        fi
        
        echo -e "${GREEN}✓${NC} Configuraciones copiadas (sin datos sensibles)"
        
        # Mostrar tamaño
        SIZE=$(du -sh "$BACKUP_DIR/User" 2>/dev/null | cut -f1 || echo "0B")
        echo -e "  Tamaño: $SIZE"
    else
        echo -e "${YELLOW}⚠${NC} Directorio de configuraciones no encontrado"
    fi
    echo ""
    
    # Crear listado de extensiones (no copiar las extensiones completas)
    echo -e "${BLUE}Generando listado de extensiones...${NC}"
    if [ -d "$CURSOR_EXTENSIONS_DIR" ]; then
        EXTENSIONS_LIST_FILE="$BACKUP_DIR/extensions_list.txt"
        
        echo "Extensiones instaladas en Cursor" > "$EXTENSIONS_LIST_FILE"
        echo "=================================" >> "$EXTENSIONS_LIST_FILE"
        echo "Fecha: $(date)" >> "$EXTENSIONS_LIST_FILE"
        echo "" >> "$EXTENSIONS_LIST_FILE"
        
        EXT_COUNT=0
        
        # Buscar todas las extensiones (carpetas que contienen package.json)
        for ext_dir in "$CURSOR_EXTENSIONS_DIR"/*; do
            if [ -d "$ext_dir" ] && [ -f "$ext_dir/package.json" ]; then
                # Leer información de la extensión desde package.json
                if command -v jq &> /dev/null; then
                    EXT_NAME=$(jq -r '.name // .displayName // "Unknown"' "$ext_dir/package.json" 2>/dev/null || echo "Unknown")
                    EXT_PUBLISHER=$(jq -r '.publisher // "Unknown"' "$ext_dir/package.json" 2>/dev/null || echo "Unknown")
                    EXT_VERSION=$(jq -r '.version // "Unknown"' "$ext_dir/package.json" 2>/dev/null || echo "Unknown")
                    EXT_DESC=$(jq -r '.description // "No description"' "$ext_dir/package.json" 2>/dev/null || echo "No description")
                else
                    EXT_NAME=$(grep -o '"name"[[:space:]]*:[[:space:]]*"[^"]*"' "$ext_dir/package.json" 2>/dev/null | head -1 | sed 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "Unknown")
                    EXT_PUBLISHER=$(grep -o '"publisher"[[:space:]]*:[[:space:]]*"[^"]*"' "$ext_dir/package.json" 2>/dev/null | head -1 | sed 's/.*"publisher"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "Unknown")
                    EXT_VERSION=$(grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' "$ext_dir/package.json" 2>/dev/null | head -1 | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "Unknown")
                    EXT_DESC=$(grep -o '"description"[[:space:]]*:[[:space:]]*"[^"]*"' "$ext_dir/package.json" 2>/dev/null | head -1 | sed 's/.*"description"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "No description")
                fi
                
                EXT_ID=$(basename "$ext_dir")
                
                echo "---" >> "$EXTENSIONS_LIST_FILE"
                echo "ID: $EXT_ID" >> "$EXTENSIONS_LIST_FILE"
                echo "Nombre: $EXT_NAME" >> "$EXTENSIONS_LIST_FILE"
                echo "Editor: $EXT_PUBLISHER" >> "$EXTENSIONS_LIST_FILE"
                echo "Versión: $EXT_VERSION" >> "$EXTENSIONS_LIST_FILE"
                echo "Descripción: $EXT_DESC" >> "$EXTENSIONS_LIST_FILE"
                echo "" >> "$EXTENSIONS_LIST_FILE"
                
                EXT_COUNT=$((EXT_COUNT + 1))
            fi
        done
        
        echo "Total de extensiones: $EXT_COUNT" >> "$EXTENSIONS_LIST_FILE"
        
        echo -e "${GREEN}✓${NC} Listado de extensiones creado"
        echo -e "  Extensiones encontradas: $EXT_COUNT"
        echo -e "  Archivo: extensions_list.txt"
    else
        echo -e "${YELLOW}⚠${NC} Directorio de extensiones no encontrado"
    fi
    echo ""
    
    # Crear archivo de información
    INFO_FILE="$BACKUP_DIR/backup_info.txt"
    cat > "$INFO_FILE" << EOF
Backup Público de Cursor (Sin información sensible)
====================================================
Fecha: $(date)
Sistema: $(uname -a)

Este backup contiene:
- Configuraciones básicas (settings.json, keybindings.json, snippets, tasks.json)
- Listado de extensiones instaladas

NO contiene:
- Extensiones completas (solo el listado)
- globalStorage (puede contener tokens y credenciales)
- workspaceStorage (puede contener datos sensibles de proyectos)
- Bases de datos de estado
- Cualquier otra información sensible

Para restaurar configuraciones:
1. Copia los archivos desde User/ a tu directorio de configuraciones de Cursor
2. Para extensiones, instálalas manualmente desde el listado en extensions_list.txt
EOF
    
    echo -e "${GREEN}✓${NC} Archivo de información creado"
    echo ""
    
    # Crear comprimido tar.gz
    echo -e "${BLUE}Comprimiendo backup...${NC}"
    ARCHIVE_NAME="cursor_backup_public_$TIMESTAMP.tar.gz"
    cd "$dest_dir"
    tar -czf "$ARCHIVE_NAME" "cursor_backup_public_$TIMESTAMP"
    echo -e "${GREEN}✓${NC} Backup comprimido: $ARCHIVE_NAME"
    
    # Verificar que el archivo se creó correctamente antes de eliminar la carpeta
    if [ -f "$dest_dir/$ARCHIVE_NAME" ]; then
        ARCHIVE_SIZE=$(du -sh "$ARCHIVE_NAME" | cut -f1)
        echo -e "  Tamaño del archivo: $ARCHIVE_SIZE"
        echo ""
        
        echo -e "${BLUE}Eliminando carpeta temporal...${NC}"
        rm -rf "$BACKUP_DIR"
        echo -e "${GREEN}✓${NC} Carpeta temporal eliminada"
        echo ""
    else
        echo -e "${YELLOW}⚠${NC} Error al crear el archivo comprimido, se mantiene la carpeta temporal"
        echo ""
    fi
    
    # Resumen final
    echo -e "${BLUE}========================================${NC}"
    echo -e "${GREEN}✓ Backup público completado exitosamente${NC}"
    echo -e "${BLUE}========================================${NC}"
    echo ""
    echo -e "Ubicación del backup:"
    echo -e "  Archivo comprimido: ${GREEN}$dest_dir/$ARCHIVE_NAME${NC}"
    echo ""
    echo -e "${YELLOW}Nota: Este backup NO contiene información sensible.${NC}"
    echo -e "${YELLOW}Incluye solo configuraciones básicas y listado de extensiones.${NC}"
    echo ""
}

# ============================================================================
# FUNCIÓN: RESTAURAR BACKUP
# ============================================================================
do_restore() {
    local backup_file="$1"
    
    if [ -z "$backup_file" ]; then
        echo -e "${RED}Error: Debes proporcionar la ruta al archivo de backup${NC}"
        echo ""
        echo "Uso: cursor-backup -r [ruta_al_backup.tar.gz]"
        echo ""
        echo "Ejemplo:"
        echo "  cursor-backup -r ~/cursor_backups/cursor_backup_20241128_120000.tar.gz"
        exit 1
    fi
    
    # Verificar que el archivo existe
    if [ ! -f "$backup_file" ]; then
        echo -e "${RED}Error: El archivo de backup no existe: $backup_file${NC}"
        exit 1
    fi
    
    echo -e "${BLUE}========================================${NC}"
    echo -e "${BLUE}  Restauración de Cursor${NC}"
    echo -e "${BLUE}========================================${NC}"
    echo ""
    
    # Confirmar restauración
    echo -e "${YELLOW}⚠ ADVERTENCIA: Esta operación sobrescribirá tus configuraciones actuales${NC}"
    echo -e "${YELLOW}   Asegúrate de haber cerrado Cursor antes de continuar${NC}"
    echo ""
    read -p "¿Deseas continuar? (s/N): " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[SsYy]$ ]]; then
        echo -e "${YELLOW}Restauración cancelada${NC}"
        exit 0
    fi
    
    # Crear directorio temporal para extraer
    TEMP_DIR=$(mktemp -d)
    echo -e "${BLUE}Extrayendo backup...${NC}"
    tar -xzf "$backup_file" -C "$TEMP_DIR"
    echo -e "${GREEN}✓${NC} Backup extraído"
    echo ""
    
    # Buscar el directorio de backup extraído
    EXTRACTED_DIR=$(find "$TEMP_DIR" -type d -name "cursor_backup_*" | head -1)
    
    if [ -z "$EXTRACTED_DIR" ]; then
        echo -e "${RED}Error: No se pudo encontrar el directorio de backup en el archivo${NC}"
        rm -rf "$TEMP_DIR"
        exit 1
    fi
    
    # Restaurar configuraciones
    if [ -d "$EXTRACTED_DIR/User" ]; then
        echo -e "${BLUE}Restaurando configuraciones...${NC}"
        
        # Crear backup de seguridad de las configuraciones actuales
        if [ -d "$CURSOR_USER_DIR" ]; then
            BACKUP_CURRENT="$HOME/cursor_backups/current_backup_$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$BACKUP_CURRENT"
            cp -R "$CURSOR_USER_DIR" "$BACKUP_CURRENT/User"
            echo -e "${GREEN}✓${NC} Backup de seguridad de configuraciones actuales creado"
        fi
        
        # Crear directorio si no existe
        mkdir -p "$(dirname "$CURSOR_USER_DIR")"
        
        # Restaurar
        rm -rf "$CURSOR_USER_DIR"
        cp -R "$EXTRACTED_DIR/User" "$CURSOR_USER_DIR"
        echo -e "${GREEN}✓${NC} Configuraciones restauradas"
    else
        echo -e "${YELLOW}⚠${NC} No se encontró directorio de configuraciones en el backup"
    fi
    echo ""
    
    # Restaurar extensiones
    if [ -d "$EXTRACTED_DIR/extensions" ]; then
        echo -e "${BLUE}Restaurando extensiones...${NC}"
        
        # Crear backup de seguridad de las extensiones actuales
        if [ -d "$CURSOR_EXTENSIONS_DIR" ]; then
            BACKUP_CURRENT="$HOME/cursor_backups/current_backup_$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$BACKUP_CURRENT"
            cp -R "$CURSOR_EXTENSIONS_DIR" "$BACKUP_CURRENT/extensions"
            echo -e "${GREEN}✓${NC} Backup de seguridad de extensiones actuales creado"
        fi
        
        # Crear directorio si no existe
        mkdir -p "$(dirname "$CURSOR_EXTENSIONS_DIR")"
        
        # Restaurar
        rm -rf "$CURSOR_EXTENSIONS_DIR"
        cp -R "$EXTRACTED_DIR/extensions" "$CURSOR_EXTENSIONS_DIR"
        echo -e "${GREEN}✓${NC} Extensiones restauradas"
        
        # Contar extensiones
        EXT_COUNT=$(find "$CURSOR_EXTENSIONS_DIR" -maxdepth 1 -type d | wc -l | tr -d ' ')
        echo -e "  Extensiones restauradas: $((EXT_COUNT - 1))"
    else
        echo -e "${YELLOW}⚠${NC} No se encontró directorio de extensiones en el backup"
    fi
    echo ""
    
    # Limpiar directorio temporal
    rm -rf "$TEMP_DIR"
    
    # Resumen final
    echo -e "${BLUE}========================================${NC}"
    echo -e "${GREEN}✓ Restauración completada exitosamente${NC}"
    echo -e "${BLUE}========================================${NC}"
    echo ""
    echo -e "Ahora puedes abrir Cursor y tus configuraciones y extensiones"
    echo -e "deberían estar restauradas."
    echo ""
}

# ============================================================================
# EJECUTAR SEGÚN MODO
# ============================================================================

if [ "$RESTORE_MODE" = true ]; then
    do_restore "$BACKUP_FILE"
elif [ "$PUBLIC_MODE" = true ]; then
    do_backup_public "$BACKUP_BASE_DIR"
else
    do_backup_complete "$BACKUP_BASE_DIR"
fi

